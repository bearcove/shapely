use std::iter;

// Generate implementations for function pointers up to the following arity
const MAX_ARITY: i32 = 6;
// Generate implementations for the following calling conventions
// (abi-string, abi-enum-variant-name)
#[rustfmt::skip]
const ABIS: &[(&str, &str)] = &[
    ("Rust", "Rust"),
    ("C", "C"),
];

/// Generate implementations for function pointers. It's highly repetitive and hard to get done with only
/// declarative macros. So that's why it's generated.
pub fn generate() -> String {
    use std::fmt::Write;
    let mut s = String::with_capacity(65536);

    macro_rules! w {
        ($($t:tt)*) => {
            write!(s, $($t)*).unwrap()
        };
    }

    // Header
    w!("//! GENERATED: DO NOT EDIT — this file is generated by the `facet-dev` crate.\n");
    w!("//! Run `just gen` to regenerate.\n\n");

    w!("use core::{{alloc::Layout, fmt}};\n\n");
    w!("use crate::{{\n");
    w!("    value_vtable, ConstTypeId, Def, Facet, FunctionAbi,\n");
    w!("    FunctionPointerDef, Shape, TypeNameOpts, TypeParam\n");
    w!("}};
\n");

    // Helper functions
    w!("#[inline(always)]\n");
    w!("pub fn write_type_name_list(\n");
    w!("    f: &mut fmt::Formatter<'_>,\n");
    w!("    opts: TypeNameOpts,\n");
    w!("    abi: FunctionAbi,\n");
    w!("    params: &'static [&'static Shape],\n");
    w!("    ret_type: &'static Shape,\n");
    w!(") -> fmt::Result {{\n");
    w!("    if abi != FunctionAbi::Rust {{\n");
    w!("        f.pad(\"extern \\\"\")?;\n");
    w!("        if let Some(abi) = abi.as_abi_str() {{\n");
    w!("            f.pad(abi)?;\n");
    w!("        }}\n");
    w!("        f.pad(\"\\\" \")?;\n");
    w!("    }}\n");
    w!("    f.pad(\"fn\")?;\n");
    w!("    f.pad(\"(\")?;\n");
    w!("    if let Some(opts) = opts.for_children() {{\n");
    w!("        for (index, shape) in params.iter().enumerate() {{\n");
    w!("            if index > 0 {{\n");
    w!("                f.pad(\", \")?;\n");
    w!("            }}\n");
    w!("            shape.write_type_name(f, opts)?;\n");
    w!("        }}\n");
    w!("    }} else {{\n");
    w!("        write!(f, \"⋯\")?;\n");
    w!("    }}\n");
    w!("    f.pad(\") -> \")?;\n");
    w!("    ret_type.write_type_name(f, opts)?;\n");
    w!("    Ok(())\n");
    w!("}}\n\n");

    for &(abi_string, abi_name) in ABIS {
        for n in 0..=MAX_ARITY {
            let return_param = String::from("R");
            // Generate type parameters and where clauses
            let type_params = (0..n)
                .map(|i| format!("T{}", i))
                .collect::<Vec<_>>()
                .join(", ");
            let where_predicates = (0..n)
                .map(|i| format!("T{}: Facet", i))
                .chain(iter::once("R: Facet".to_owned()))
                .collect::<Vec<_>>()
                .join(",\n    ");
            let param_shape_list = (0..n)
                .map(|i| format!("T{}::SHAPE", i))
                .collect::<Vec<_>>()
                .join(", ");
            let param_shape_ctor = (0..n)
                .map(|i| format!("|| T{}::SHAPE", i))
                .collect::<Vec<_>>()
                .join(", ");

            let type_param_build = (0..n)
                .map(|i| format!("TypeParam {{ name: \"T{i}\", shape: || T{i}::SHAPE }}"))
                .collect::<Vec<_>>()
                .join(", ");

            let extern_abi = if abi_string == "Rust" {
                String::new()
            } else {
                format!("extern \"{abi_string}\" ")
            };

            // Start impl block
            w!(
                "unsafe impl<{return_param}, {type_params}> Facet for {extern_abi}fn({type_params}) -> {return_param}\n",
            );
            w!("where\n");
            w!("    {}\n", where_predicates);
            w!("{{\n");
            w!("    const SHAPE: &'static Shape = &const {{\n");

            // type_name function
            w!(
                "        fn type_name<{return_param}, {type_params}>(f: &mut fmt::Formatter, opts: TypeNameOpts) -> fmt::Result\n",
            );
            w!("        where\n");
            w!("            {}\n", where_predicates);
            w!("        {{\n");
            w!("            write_type_name_list(\n");
            w!("                f,\n");
            w!("                opts,\n");
            w!("                FunctionAbi::{abi_name},\n");
            w!("                &[\n");
            w!("                    {}\n", param_shape_list);
            w!("                ],\n");
            w!("                {return_param}::SHAPE,\n");
            w!("            )\n");
            w!("        }}\n\n");

            // Shape builder start
            w!("        Shape::builder()\n");
            w!("            .id(ConstTypeId::of::<Self>())\n");
            w!("            .layout(Layout::new::<Self>())\n");
            // FIXME: Dont use the macro here we can generate this
            // FIXME: type name
            w!(
                "            .vtable(value_vtable!(Self, type_name::<{return_param}, {type_params}>))\n"
            );
            w!("            .type_params(&[{type_param_build}])\n");
            w!("            .def(Def::FunctionPointer({{\n");
            w!("                FunctionPointerDef::builder()\n");
            w!("                    .parameter_types(&const {{ [{param_shape_ctor}] }})\n");
            w!("                    .return_type(|| R::SHAPE)\n");
            w!("                    .abi(FunctionAbi::{})\n", abi_name);
            w!("                    .build()\n");
            w!("            }}))\n");

            // Finish implementation
            w!("            .build()\n");
            w!("    }};\n");
            w!("}}\n");
        }
    }
    s
}
